<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>BA理论解读 | SUQIGUANG's BLOG</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">BA理论解读</h1><a id="logo" href="/.">SUQIGUANG's BLOG</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">BA理论解读</h1><div class="post-meta">Sep 28, 2019</div><div class="post-content"><h2 id="BA理论解读"><a href="#BA理论解读" class="headerlink" title="BA理论解读"></a>BA理论解读</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.  基本原理"></a>1.  基本原理</h3><h4 id="1-1-BA介绍"><a href="#1-1-BA介绍" class="headerlink" title="1.1 BA介绍"></a>1.1 BA介绍</h4><p>最小化重投影误差，获得最优的机器人位姿估计。bundle指的是光束，就是通过针孔相机模型获得的像素。重投影误差指的真实三维空间点在图像平面上的投影像素（真实值）和通过针孔相机模型计算得到的像素（估计值）差值。</p>
<blockquote>
<p>这些东西归根结底就是Gauss“发明”的least squares method（最小二乘法）。当年天文学家Piazzi整天闲得没事看星星，在1801年1月1号早上发现了一个从来没观测到的星星，再接下来的42天里做了19次观测之后这个星星就消失了。当时的天文学家为了确定这玩意到底是什么绞尽了脑汁，这时候Gauss出现了，（最初）只用了3个观察数据，就用least squares算出了这个小行星的轨道，接下来天文学家根据Gauss的预测，也重新发现了这个小行星（虽然有小小的偏差），并将其命名为Ceres，也就是谷神星。Google的ceres-solver就是根据这个来命名的。</p>
</blockquote>
<h4 id="1-2-BA建模"><a href="#1-2-BA建模" class="headerlink" title="1.2 BA建模"></a>1.2 BA建模</h4><p>相机投影模型如下，其中：$s_i$为比例参数；$K$为内参矩阵（形式如式2）；$\exp \left(\boldsymbol{\xi}^{\wedge}\right)$为李代数表示的外参，$\xi$是一个1×6的向量（为什么不直接用一个4×4的矩阵直接表示外参呢？）</p>
<script type="math/tex; mode=display">
s_{i}\left[\begin{array}{c}{u_{i}} \\ {v_{i}} \\ {1}\end{array}\right]=\boldsymbol{K} \exp \left(\boldsymbol{\xi}^{\wedge}\right)\left[\begin{array}{c}{X_{i}} \\ {Y_{i}} \\ {Z_{i}} \\ {1}\end{array}\right]</script><p>其中：</p>
<script type="math/tex; mode=display">
\boldsymbol{K}=\left[\begin{array}{ccc}{f_{x}} & {0} & {c_{x}} \\ {0} & {f_{y}} & {c_{y}} \\ {0} & {0} & {1}\end{array}\right]</script><p>令：</p>
<script type="math/tex; mode=display">
\boldsymbol{P}^{\prime}=\left(\exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{P}\right)_{1 : 3}=\left[X^{\prime}, Y^{\prime}, Z^{\prime}\right]^{\mathrm{T}}</script><p>则</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}{s u} \\ {s v} \\ {s}\end{array}\right]=\left[\begin{array}{ccc}{f_{x}} & {0} & {c_{x}} \\ {0} & {f_{y}} & {c_{y}} \\ {0} & {0} & {1}\end{array}\right]\left[\begin{array}{c}{X^{\prime}} \\ {Y^{\prime}} \\ {Z^{\prime}}\end{array}\right]</script><p>由第三行可得$s=Z^{‘}$,则重投影（估计的）像素坐标为</p>
<script type="math/tex; mode=display">
u=f_{x} \frac{X^{\prime}}{Z^{\prime}}+c_{x}, \quad v=f_{y} \frac{Y^{\prime}}{Z^{\prime}}+c_{y}</script><p>构建最小二乘问题，寻找最优相机位姿</p>
<script type="math/tex; mode=display">
\xi^{*}=\arg \min _{\xi} \frac{1}{2} \sum_{i=1}^{n}\left\|\boldsymbol{u}_{i}-\frac{1}{s_{i}} \boldsymbol{K} \exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{P}_{i}\right\|_{2}^{2}</script><p>使用李代数，我们构建了无约束的优化问题，很方便地通过高斯牛顿法、L-M方法等优化算法进行求解。不过，在使用高斯牛顿法和L-M方法之前，我们需要知道每个误差项关于优化变量的导数，也就是线性化：</p>
<p>令</p>
<script type="math/tex; mode=display">
e(x)=\boldsymbol{u}_{i}-\frac{1}{s_{i}} \boldsymbol{K} \exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{P}_{i}</script><p>则</p>
<script type="math/tex; mode=display">
e(x+\Delta x) \approx e(x)+J \Delta x</script><p>构建最小二乘，对方程进行求导，得到下式（即我们常说的正规方程）</p>
<script type="math/tex; mode=display">
\boldsymbol{J}(\boldsymbol{x}) e(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x}) \boldsymbol{J}^{\mathrm{T}}(\boldsymbol{x}) \Delta \boldsymbol{x}=\mathbf{0}</script><p>化简：</p>
<script type="math/tex; mode=display">
\underbrace{J(x) J^{\mathrm{T}}}_{H(x)}(x) \Delta x=\underbrace{-J(x) f(x)}_{g(x)}</script><p>得到增量方程</p>
<script type="math/tex; mode=display">
\boldsymbol{H} \Delta \boldsymbol{x}=\boldsymbol{g}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定初始值 x0。</span><br><span class="line">对于第 k 次迭代，求出当前的雅可比矩阵 J(x_k) 和误差 f(x_k)。</span><br><span class="line">求解增量方程： H∆x_k = g。</span><br><span class="line">若 ∆x_k 足够小，则停止。否则，令 x_&#123;k+1&#125; = x_k + ∆x_k，返回第 2 步。</span><br></pre></td></tr></table></figure>
<p>这里的 $J​$ 的形式是值得讨论的，甚至可以说是关键所在。</p>
<script type="math/tex; mode=display">
J=\frac{\partial e}{\partial \delta \xi}=\lim _{\delta \xi \rightarrow 0} \frac{e(\delta \xi \oplus \xi)}{\delta \xi}=\frac{\partial e}{\partial P^{\prime}} \frac{\partial P^{\prime}}{\partial \delta \xi}</script><p>其中</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial \boldsymbol{P}^{\prime}}=-\left[\begin{array}{ccc}{\frac{\partial u}{\partial X^{\prime}}} & {\frac{\partial u}{\partial Y^{\prime}}} & {\frac{\partial u}{\partial Z^{\prime}}} \\ {\frac{\partial v}{\partial X^{\prime}}} & {\frac{\partial v}{\partial Y^{\prime}}} & {\frac{\partial v}{\partial Z^{\prime}}}\end{array}\right]=-\left[\begin{array}{ccc}{\frac{f_{x}}{Z^{\prime}}} & {0} & {-\frac{f_{x} X^{\prime}}{Z^{\prime 2}}} \\ {0} & {\frac{f_{y}}{Z^{\prime}}} & {-\frac{f_{y} Y^{\prime}}{Z^{\prime 2}}}\end{array}\right]</script><script type="math/tex; mode=display">
\frac{\partial(\boldsymbol{T} \boldsymbol{P})}{\partial \delta \boldsymbol{\xi}}=(\boldsymbol{T} \boldsymbol{P})^{\odot}=\left[\begin{array}{cc}{\boldsymbol{I}} & {-\boldsymbol{P}^{\prime \wedge}} \\ {\mathbf{0}^{\mathrm{T}}} & {\mathbf{0}^{\mathrm{T}}}\end{array}\right]</script><p>上面两项相乘</p>
<script type="math/tex; mode=display">
J_{\xi}=\frac{\partial e}{\partial \delta \xi}=-\left[\begin{array}{cccccc}{\frac{f_{x}}{Z^{\prime}}} & {0} & {-\frac{f_{x} X^{\prime}}{Z^{\prime 2}}} & {-\frac{f_{x} X^{\prime} Y^{\prime}}{Z^{\prime 2}}} & {f_{x}+\frac{f_{x} X^{2}}{Z^{\prime 2}}} & {-\frac{f_{x} Y^{\prime}}{Z^{\prime}}} \\ {0} & {\frac{f_{y}}{z^{\prime}}} & {-\frac{f_{y} Y^{\prime}}{2^{\prime 2}}} & {-f_{y}-\frac{f_{y} Y^{\prime 2}}{Z^{\prime 2}}} & {\frac{f_{y} X^{\prime} Y^{\prime}}{Z^{\prime 2}}} & {\frac{f_{y} X^{\prime}}{Z^{\prime}}}\end{array}\right]</script><p>另一方面，除了优化位姿，我们还希望优化特征点的空间位置。因此，需要讨论 e 关于空间点<br>P 的导数。所幸这个导数矩阵相对来说容易一些。仍利用链式法则，有：</p>
<script type="math/tex; mode=display">
J_P=\frac{\partial e}{\partial P}=\frac{\partial e}{\partial P^{\prime}} \frac{\partial P^{\prime}}{\partial P}</script><script type="math/tex; mode=display">
J_P=\frac{\partial e}{\partial \boldsymbol{P}}=-\left[\begin{array}{ccc}{\frac{f_{x}}{Z^{\prime}}} & {0} & {-\frac{f_{x} X^{\prime}}{Z^{\prime 2}}} \\ {0} & {\frac{f_{y}}{Z^{\prime}}} & {-\frac{f_{y} Y^{\prime}}{Z^{\prime 2}}}\end{array}\right] \boldsymbol{R}</script><p>上述方法适用于前端小型BA的实时求解。</p>
<p>对于大型BA的求解就不得不了解$H$矩阵的稀疏性。</p>
<p><img src="/home/sqg/.config/Typora/typora-user-images/1567691035382.png" alt="1567691035382"></p>
<p><img src="/home/sqg/.config/Typora/typora-user-images/1567691092817.png" alt="1567691092817"></p>
<p><img src="/home/sqg/.config/Typora/typora-user-images/1567691123720.png" alt="1567691123720"></p>
<p><img src="/home/sqg/.config/Typora/typora-user-images/1567691140838.png" alt="1567691140838"></p>
<h3 id="2-非线性最小二乘与因子图之间的联系"><a href="#2-非线性最小二乘与因子图之间的联系" class="headerlink" title="2. 非线性最小二乘与因子图之间的联系"></a>2. 非线性最小二乘与因子图之间的联系</h3><p>Dellaert, F.和 Kaess, M的论文Square Root SAM中揭示了因子图与非线性最小二乘之间紧密的联系。因子图是一个概率图形模型，它表示所有因子的联合概率分布</p>
<script type="math/tex; mode=display">
p(x) \propto \prod_i p_i(x_i)</script><script type="math/tex; mode=display">
x^{*} = \operatorname*{argmax}_{x} p(x) = \operatorname*{argmax}_{x} \prod_i p_i(x_i).</script><p>如果考虑每个因子在$f_i(x_i)​$上具有高斯分布且协方差$Σ_i​$的情况，</p>
<p>那么MAP推断是</p>
<p>等式中的MAP推理问题被转换成上面提到的形式相同的非线性最小二乘优化问题。可以按照前一节中相同的步骤解决。</p>
<p>使用因子图对SLAM中的非线性最小二乘问题建模有几个优点。因子图对问题的概率性质进行编码，并且可以轻松地可视化大多数SLAM问题的潜在稀疏性，因为大多数（如果不是全部）因子$x_i​$都是很小的集合。</p>
<h3 id="3-代码实践（使用ceres）"><a href="#3-代码实践（使用ceres）" class="headerlink" title="3. 代码实践（使用ceres）"></a>3. 代码实践（使用ceres）</h3><p><a href="http://grail.cs.washington.edu/projects/bal/" target="_blank" rel="noopener">参考</a></p>
<p><strong>假设：</strong>使用针孔相机模型；相机旋转$R$，平移$t$，焦距$f$和两个径向畸变参数$k1$和$k2$。将3D点$X$投影到摄像机为参数$R，t，f，k1，k2$表示u的公式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P = R * X + t（从世界坐标转换为相机坐标）</span><br><span class="line"></span><br><span class="line">p = -P / P.z（归一化除法）</span><br><span class="line"></span><br><span class="line">p&apos;= f * r（p）* p（转换为像素坐标）</span><br></pre></td></tr></table></figure>
<p>其中P.z是P的第三个（z）坐标。在最后一个方程中，r（p）是一个消除径向畸变的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r(p) = 1.0 + k1 * ||p||^2 + k2 * ||p||^4.</span><br></pre></td></tr></table></figure>
<p>这样就给出了以像素为单位的投影，其中图像的原点是图像的中心，x轴的正指向右，y轴的正指向上方（此外，在相机坐标系中，z轴为正轴指向后方，因此相机向下看Z轴的负方向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/rotation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 Bundle Adjustment in the Large 数据集.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BALProblem</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~BALProblem()    <span class="comment">// 析构函数：自动/手动释放对象使用的资源，销毁非static成员</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] point_index_;</span><br><span class="line">    <span class="keyword">delete</span>[] camera_index_;</span><br><span class="line">    <span class="keyword">delete</span>[] observations_;</span><br><span class="line">    <span class="keyword">delete</span>[] parameters_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些类内函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">num_observations</span><span class="params">()</span>       <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_observations_;               &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">double</span>* <span class="title">observations</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> observations_;                   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_cameras</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> parameters_;                     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_points</span><span class="params">()</span>           </span>&#123; <span class="keyword">return</span> parameters_  + <span class="number">9</span> * num_cameras_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_camera_for_observation</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutable_cameras() + camera_index_[i] * <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_point_for_observation</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutable_points() + point_index_[i] * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* fptr = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_cameras_);</span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_points_);</span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_observations_);</span><br><span class="line"></span><br><span class="line">    point_index_ = <span class="keyword">new</span> <span class="keyword">int</span>[num_observations_];</span><br><span class="line">    camera_index_ = <span class="keyword">new</span> <span class="keyword">int</span>[num_observations_];</span><br><span class="line">    observations_ = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">2</span> * num_observations_];</span><br><span class="line"></span><br><span class="line">    num_parameters_ = <span class="number">9</span> * num_cameras_ + <span class="number">3</span> * num_points_;</span><br><span class="line">    parameters_ = <span class="keyword">new</span> <span class="keyword">double</span>[num_parameters_];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_observations_; ++i) &#123;</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%d"</span>, camera_index_ + i);</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%d"</span>, point_index_ + i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        FscanfOrDie(fptr, <span class="string">"%lf"</span>, observations_ + <span class="number">2</span>*i + j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_parameters_; ++i) &#123;</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%lf"</span>, parameters_ + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模板函数，读取文件或中断</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FscanfOrDie</span><span class="params">(FILE *fptr, <span class="keyword">const</span> <span class="keyword">char</span> *format, T *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_scanned = <span class="built_in">fscanf</span>(fptr, format, value);</span><br><span class="line">    <span class="keyword">if</span> (num_scanned != <span class="number">1</span>) &#123;</span><br><span class="line">      LOG(FATAL) &lt;&lt; <span class="string">"Invalid UW data file."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类内初始化</span></span><br><span class="line">  <span class="keyword">int</span> num_cameras_;</span><br><span class="line">  <span class="keyword">int</span> num_points_;</span><br><span class="line">  <span class="keyword">int</span> num_observations_;</span><br><span class="line">  <span class="keyword">int</span> num_parameters_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* point_index_;</span><br><span class="line">  <span class="keyword">int</span>* camera_index_;</span><br><span class="line">  <span class="keyword">double</span>* observations_;</span><br><span class="line">  <span class="keyword">double</span>* parameters_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重投影误差</span></span><br><span class="line"><span class="comment">// 构建针孔相机模型。使用9个参数对摄像机进行参数设置：3个用于旋转，3个用于平移，</span></span><br><span class="line"><span class="comment">// 1个用于焦距和2个用于径向畸变（假定主点位于图像中心）。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnavelyReprojectionError</span> &#123;</span></span><br><span class="line">  <span class="comment">// 初始化构造函数</span></span><br><span class="line">  SnavelyReprojectionError(<span class="keyword">double</span> observed_x, <span class="keyword">double</span> observed_y)</span><br><span class="line">      : observed_x(observed_x), observed_y(observed_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> T* <span class="keyword">const</span> point,</span></span></span><br><span class="line"><span class="function"><span class="params">                  T* residuals)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// camera[0] camera[1] camera[2] 为angle-axis旋转.</span></span><br><span class="line">    T p[<span class="number">3</span>];</span><br><span class="line">    ceres::AngleAxisRotatePoint(camera, point, p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera[3] camera[4] camera[5] 为平移矩阵.</span></span><br><span class="line">    p[<span class="number">0</span>] += camera[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">1</span>] += camera[<span class="number">4</span>];</span><br><span class="line">    p[<span class="number">2</span>] += camera[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算畸变的中心。符号变化来自Snavely的Bundler中所采用的相机模型，因此相机坐标系的Z轴为负。</span></span><br><span class="line">    T xp = - p[<span class="number">0</span>] / p[<span class="number">2</span>];</span><br><span class="line">    T yp = - p[<span class="number">1</span>] / p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用第二项和第四项径向畸变，即camera[7] camera[8]。</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; l1 = camera[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">const</span> T&amp; l2 = camera[<span class="number">8</span>];</span><br><span class="line">    T r2 = xp*xp + yp*yp;</span><br><span class="line">    T distortion = <span class="number">1.0</span> + r2  * (l1 + l2  * r2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute final projected point position.</span></span><br><span class="line">    <span class="comment">// 计算最终的投影点位置，其中camera[6]为焦距参数。</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; focal = camera[<span class="number">6</span>];</span><br><span class="line">    T predicted_x = focal * distortion * xp;</span><br><span class="line">    T predicted_y = focal * distortion * yp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 误差是预测位置和观察位置之间的差异，求x和y的残差。</span></span><br><span class="line">    residuals[<span class="number">0</span>] = predicted_x - observed_x;</span><br><span class="line">    residuals[<span class="number">1</span>] = predicted_y - observed_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将CostFunction对象的构造隐藏在类内。</span></span><br><span class="line">  <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> observed_x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> <span class="keyword">double</span> observed_y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用自动求导</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;SnavelyReprojectionError, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>&gt;(</span><br><span class="line">                <span class="keyword">new</span> SnavelyReprojectionError(observed_x, observed_y)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> observed_x;</span><br><span class="line">  <span class="keyword">double</span> observed_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"usage: simple_bundle_adjuster &lt;bal_problem&gt;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BALProblem bal_problem&#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!bal_problem.LoadFile(argv[<span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: unable to open file "</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span>* observations = bal_problem.observations();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为BA问题中的每个观测值创建残差。自动添加摄像机和点的参数。</span></span><br><span class="line">  ceres::Problem problem;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem.num_observations(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 每个残差块均以一个点和一个摄像机作为输入，并输出2维残差。</span></span><br><span class="line">    <span class="comment">// 在内部，cost function 存储观察到的图像位置，并将重投影与观察值进行比较。</span></span><br><span class="line">    ceres::CostFunction* cost_function =</span><br><span class="line">        SnavelyReprojectionError::Create(observations[<span class="number">2</span> * i + <span class="number">0</span>],</span><br><span class="line">                                         observations[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">    problem.AddResidualBlock(cost_function,</span><br><span class="line">                             <span class="literal">nullptr</span> <span class="comment">/* squared loss */</span>,</span><br><span class="line">                             bal_problem.mutable_camera_for_observation(i),</span><br><span class="line">                             bal_problem.mutable_point_for_observation(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用Ceres自动求解。注意，标准求解器SPARSE_NORMAL_CHOLESKY</span></span><br><span class="line">  <span class="comment">// 也可以正常工作，但是对于标准BA问题来说速度较慢。（DENSE_SCHUR速度会比较快）</span></span><br><span class="line">  ceres::Solver::Options options;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  ceres::Solver::Summary summary;</span><br><span class="line">  ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数据集</strong>：BAL数据集，来源于 <a href="http://grail.cs.washington.edu/rome" target="_blank" rel="noopener">Building Rome in a Day</a>项目。使用到的数据中包含16台相机拍摄到的22106特征点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">数据集部分数据，其按下面格式排列</span><br><span class="line">&lt;num_cameras&gt; &lt;num_points&gt; &lt;num_observations&gt;</span><br><span class="line">&lt;camera_index_1&gt; &lt;point_index_1&gt; &lt;x_1&gt; &lt;y_1&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">16 22106 83718</span><br><span class="line">0 0     -3.859900e+02 3.871200e+02</span><br><span class="line">1 0     -3.844000e+01 4.921200e+02</span><br><span class="line">2 0     -6.679200e+02 1.231100e+02</span><br><span class="line">7 0     -5.991800e+02 4.079300e+02</span><br><span class="line">12 0     -7.204300e+02 3.143400e+02</span><br><span class="line">13 0     -1.151300e+02 5.548999e+01</span><br><span class="line">0 1     3.838800e+02 -1.529999e+01</span><br><span class="line">1 1     5.597500e+02 -1.061500e+02</span><br><span class="line">10 1     3.531899e+02 1.649500e+02</span><br><span class="line">0 2     5.915500e+02 1.364400e+02</span><br><span class="line">1 2     8.638600e+02 -2.346997e+01</span><br><span class="line">2 2     4.947200e+02 1.125200e+02</span><br><span class="line">6 2     4.087800e+02 2.846700e+02</span><br><span class="line">7 2     4.246100e+02 3.101700e+02</span><br><span class="line">9 2     2.848900e+02 1.928900e+02</span><br><span class="line">10 2     5.826200e+02 3.637200e+02</span><br><span class="line">12 2     4.940601e+02 2.939500e+02</span><br><span class="line">13 2     7.968300e+02 -7.853003e+01</span><br><span class="line">15 2     7.798900e+02 4.082500e+02</span><br></pre></td></tr></table></figure>
<p>使用DENSE_SCHUR方法求解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  4.185660e+06    0.00e+00    1.09e+08   0.00e+00   0.00e+00  1.00e+04        0    7.20e+00    7.90e+00</span><br><span class="line">   </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   6  1.803390e+04    9.02e-02    6.35e+01   8.00e-01   1.00e+00  2.50e+06        1    3.28e+01    2.03e+02（约合3.4min）</span><br><span class="line"></span><br><span class="line">                                     Original                  Reduced</span><br><span class="line">Parameter blocks                        22122                    22122</span><br><span class="line">Parameters                              66462                    66462</span><br><span class="line">Residual blocks                         83718                    83718</span><br><span class="line">Residuals                              167436                   167436</span><br><span class="line"></span><br><span class="line">Minimizer                        TRUST_REGION</span><br><span class="line"></span><br><span class="line">Dense linear algebra library            EIGEN</span><br><span class="line">Trust region strategy     LEVENBERG_MARQUARDT</span><br><span class="line"></span><br><span class="line">                                        Given                     Used</span><br><span class="line">Linear solver                     DENSE_SCHUR              DENSE_SCHUR</span><br><span class="line">Threads                                     1                        1</span><br><span class="line">Linear solver ordering              AUTOMATIC                 22106,16</span><br><span class="line">Schur structure                         2,3,9                    2,3,9</span><br><span class="line"></span><br><span class="line">Cost:</span><br><span class="line">Initial                          4.185660e+06</span><br><span class="line">Final                            1.803390e+04</span><br><span class="line">Change                           4.167626e+06</span><br><span class="line"></span><br><span class="line">Minimizer iterations                        7</span><br><span class="line">Successful steps                            7</span><br><span class="line">Unsuccessful steps                          0</span><br><span class="line"></span><br><span class="line">Time (in seconds):</span><br><span class="line">Preprocessor                         0.700777</span><br><span class="line"></span><br><span class="line">  Residual only evaluation           0.667742 (7)</span><br><span class="line">  Jacobian &amp; residual evaluation    39.360399 (7)</span><br><span class="line">  Linear solver                    183.064203 (7)</span><br><span class="line">Minimizer                          229.831484</span><br><span class="line"></span><br><span class="line">Postprocessor                        0.014315</span><br><span class="line">Total                              230.546577</span><br><span class="line"></span><br><span class="line">Termination:                      CONVERGENCE (Function tolerance reached. |cost_change|/cost: 1.769759e-09 &lt;= 1.000000e-06)</span><br></pre></td></tr></table></figure>
<p>使用SPARSE_SCHUR求解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  4.185660e+06    0.00e+00    1.09e+08   0.00e+00   0.00e+00  1.00e+04        0    6.34e+00    6.86e+00</span><br><span class="line">   </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   6  1.803390e+04    9.02e-02    6.35e+01   8.00e-01   1.00e+00  2.50e+06        1    3.30e+01    2.05e+02（约合3.4min）</span><br><span class="line"></span><br><span class="line">                                     Original                  Reduced</span><br><span class="line">Parameter blocks                        22122                    22122</span><br><span class="line">Parameters                              66462                    66462</span><br><span class="line">Residual blocks                         83718                    83718</span><br><span class="line">Residuals                              167436                   167436</span><br><span class="line"></span><br><span class="line">Minimizer                        TRUST_REGION</span><br><span class="line"></span><br><span class="line">Sparse linear algebra library    SUITE_SPARSE</span><br><span class="line">Trust region strategy     LEVENBERG_MARQUARDT</span><br><span class="line"></span><br><span class="line">                                        Given                     Used</span><br><span class="line">Linear solver                    SPARSE_SCHUR             SPARSE_SCHUR</span><br><span class="line">Threads                                     1                        1</span><br><span class="line">Linear solver ordering              AUTOMATIC                 22106,16</span><br><span class="line">Schur structure                         2,3,9                    2,3,9</span><br><span class="line"></span><br><span class="line">Cost:</span><br><span class="line">Initial                          4.185660e+06</span><br><span class="line">Final                            1.803390e+04</span><br><span class="line">Change                           4.167626e+06</span><br><span class="line"></span><br><span class="line">Minimizer iterations                        7</span><br><span class="line">Successful steps                            7</span><br><span class="line">Unsuccessful steps                          0</span><br><span class="line"></span><br><span class="line">Time (in seconds):</span><br><span class="line">Preprocessor                         0.524276</span><br><span class="line"></span><br><span class="line">  Residual only evaluation           0.655267 (7)</span><br><span class="line">  Jacobian &amp; residual evaluation    38.889743 (7)</span><br><span class="line">  Linear solver                    185.728749 (7)</span><br><span class="line">Minimizer                          231.991205</span><br><span class="line"></span><br><span class="line">Postprocessor                        0.010115</span><br><span class="line">Total                              232.525597</span><br><span class="line"></span><br><span class="line">Termination:                      CONVERGENCE (Function tolerance reached. |cost_change|/cost: 1.769757e-09 &lt;= 1.000000e-06)</span><br></pre></td></tr></table></figure>
<p>使用SPARSE_NORMAL_CHOLESKY方法求解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  4.185660e+06    0.00e+00    1.09e+08   0.00e+00   0.00e+00  1.00e+04        0    6.46e+00    6.63e+00</span><br><span class="line">   </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   6  1.803390e+04    9.02e-02    6.35e+01   8.00e-01   1.00e+00  2.50e+06        1    6.63e+00    4.68e+01（约合0.8min）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                     Original                  Reduced</span><br><span class="line">Parameter blocks                        22122                    22122</span><br><span class="line">Parameters                              66462                    66462</span><br><span class="line">Residual blocks                         83718                    83718</span><br><span class="line">Residuals                              167436                   167436</span><br><span class="line"></span><br><span class="line">Minimizer                        TRUST_REGION</span><br><span class="line"></span><br><span class="line">Sparse linear algebra library    SUITE_SPARSE</span><br><span class="line">Trust region strategy     LEVENBERG_MARQUARDT</span><br><span class="line"></span><br><span class="line">                                        Given                     Used</span><br><span class="line">Linear solver          SPARSE_NORMAL_CHOLESKY   SPARSE_NORMAL_CHOLESKY</span><br><span class="line">Threads                                     1                        1</span><br><span class="line">Linear solver ordering              AUTOMATIC                    22122</span><br><span class="line"></span><br><span class="line">Cost:</span><br><span class="line">Initial                          4.185660e+06</span><br><span class="line">Final                            1.803390e+04</span><br><span class="line">Change                           4.167626e+06</span><br><span class="line"></span><br><span class="line">Minimizer iterations                        7</span><br><span class="line">Successful steps                            7</span><br><span class="line">Unsuccessful steps                          0</span><br><span class="line"></span><br><span class="line">Time (in seconds):</span><br><span class="line">Preprocessor                         0.173184</span><br><span class="line"></span><br><span class="line">  Residual only evaluation           0.591482 (7)</span><br><span class="line">  Jacobian &amp; residual evaluation    38.593874 (7)</span><br><span class="line">  Linear solver                      1.753153 (7)</span><br><span class="line">Minimizer                           47.594235</span><br><span class="line"></span><br><span class="line">Postprocessor                        0.009093</span><br><span class="line">Total                               47.776512</span><br><span class="line"></span><br><span class="line">Termination:                      CONVERGENCE (Function tolerance reached. |cost_change|/cost: 1.769774e-09 &lt;= 1.000000e-06)</span><br></pre></td></tr></table></figure>
<p>使用DENSE_NORMAL_CHOLESKY求解</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of 'std::bad_alloc'</span><br></pre></td></tr></table></figure>
<p>提示超内存了……</p>
</div><div class="tags"><a href="/tags/ceres/">ceres</a></div><div class="post-nav"><a class="next" href="/2019/08/18/ceres库使用说明/">ceres库使用说明</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ceres/" style="font-size: 15px;">ceres</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/28/BA理论解读/">BA理论解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/18/ceres库使用说明/">ceres库使用说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/18/ceres库基本介绍/">ceres库基本</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">SUQIGUANG's BLOG.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>