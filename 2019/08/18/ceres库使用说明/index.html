<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ceres库使用说明 | SUQIGUANG's BLOG</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ceres库使用说明</h1><a id="logo" href="/.">SUQIGUANG's BLOG</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ceres库使用说明</h1><div class="post-meta">Aug 18, 2019</div><div class="post-content"><p>内容大部分来自ceres<a href="http://ceres-solver.org/nnls_tutorial.html" target="_blank" rel="noopener">官网</a></p>
<hr>
<p>[TOC]</p>
<h2 id="1-非线性最小二乘"><a href="#1-非线性最小二乘" class="headerlink" title="1. 非线性最小二乘"></a>1. 非线性最小二乘</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Ceres可以解决形式的边界受约束的非线性最小二乘问题：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}{\min _{\mathbf{x}}} & {\frac{1}{2} \sum_{i} \rho_{i}\left(\left\|f_{i}\left(x_{i_{1}}, \ldots, x_{i_{k}}\right)\right\|^{2}\right)} \\ {\text { s.t. }} & {l_{j} \leq x_{j} \leq u_{j}}\end{array}</script><p>这种形式的问题在科学和工程领域广泛应用 ：从统计学中的拟合曲线到从计算机视觉中的照片构建3D模型。在本节中，我们将学习如何解决使用Ceres Solver。</p>
<p>表达式$ \rho_{i}\left(\left|f_{i}\left(x_{i_{1}}, \ldots, x_{i_{k}}\right)\right|^{2}\right) $被称为<code>ResidualBlock</code>，其中$ f_{i}(\cdot) $是一个<code>CostFunction</code>，它取决于参数块$\left[x_{i_{1}}, \dots, x_{i_{k}}\right]$。在大多数优化问题中，一组标量一起出现。例如，平移向量的三个分量和四元数的四个分量定义摄像机的姿势。我们将这样一组小标量称为<code>ParameterBlock</code>。当然，<code>ParameterBlock</code>可以只是一个参数。$l_{j}$和$u_{j}$是参数块$x_{j}​$的边界。</p>
<p>$\rho_{i}$是一个<code>LossFunction</code>。<code>LossFunction</code>是一个标量函数(即我们通常所说的核函数——见slam14讲)，用于减少异常值对非线性最小二乘问题解的影响。作为一种特殊情况，当$\rho_{i}(x)=x$，即同一性函数，并且$l_{j}=-\infty$和$u_{j}=-\infty$时，我们得到更熟悉的非线性最小二乘问题。</p>
<script type="math/tex; mode=display">
\frac{1}{2} \sum_{i}\left\|f_{i}\left(x_{i_{1}}, \ldots, x_{i_{k}}\right)\right\|^{2}</script><h3 id="1-2-Hello-World"><a href="#1-2-Hello-World" class="headerlink" title="1.2 Hello World!"></a>1.2 Hello World!</h3><p>最开始，先考虑找到函数最小值的问题：</p>
<script type="math/tex; mode=display">
\frac{1}{2}(10-x)^{2}</script><p>这是一个很简单的问题，其最小值位于$x=10$，它可以比较直观的用ceres进行求解。</p>
<p>第一步是编写一个仿函数（functor），对函数$f(x)=10-x$设为初始残差：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span> &#123;</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     residual[<span class="number">0</span>] = T(<span class="number">10.0</span>) - x[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的重要一点是<code>operator（）</code>是一个模板化方法，它假定它的所有输入和输出都是某种类型<code>T</code>。这里使用模板允许Ceres调用<code>CostFunctor :: operator &lt;T&gt;（）</code>，当需要残差值时，<code>T = double</code>，当需要雅可比行列时，使用特殊类型<code>T = Jet</code>。在 Derivatives章节中，我们将更详细地讨论向Ceres供应派生的各种方法。一旦我们有了计算残差函数的方法，就可以用它来构造一个非线性最小二乘问题并让Ceres解决它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The variable to solve for with its initial value.</span></span><br><span class="line">  <span class="keyword">double</span> initial_x = <span class="number">5.0</span>;</span><br><span class="line">  <span class="keyword">double</span> x = initial_x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build the problem.</span></span><br><span class="line">  Problem problem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the only cost function (also known as residual). This uses</span></span><br><span class="line">  <span class="comment">// auto-differentiation to obtain the derivative (jacobian).</span></span><br><span class="line">  CostFunction* cost_function =</span><br><span class="line">      <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor);</span><br><span class="line">  problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the solver!</span></span><br><span class="line">  Solver::Options options;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  Solve(options, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.BriefReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x : "</span> &lt;&lt; initial_x</span><br><span class="line">            &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; x &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoDiffCostFunction</code>将<code>CostFunctor</code>作为输入，自动区分它并为其提供<code>CostFunction</code>接口。编译和运行该函数得到以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  4.512500e+01    0.00e+00    9.50e+00   0.00e+00   0.00e+00  1.00e+04       0    5.33e-04    3.46e-03</span><br><span class="line">   1  4.511598e-07    4.51e+01    9.50e-04   9.50e+00   1.00e+00  3.00e+04       1    5.00e-04    4.05e-03</span><br><span class="line">   2  5.012552e-16    4.51e-07    3.17e-08   9.50e-04   1.00e+00  9.00e+04       1    1.60e-05    4.09e-03</span><br><span class="line">Ceres Solver Report: Iterations: 2, Initial cost: 4.512500e+01, Final cost: 5.012552e-16, Termination: CONVERGENCE</span><br><span class="line">x : 0.5 -&gt; 10</span><br></pre></td></tr></table></figure>
<p>从$x=5$开始，两次迭代中的求解器变为10。细心的读者会注意到这是一个线性问题，一个线性求解应该足以得到最优值。求解器的默认配置针对非线性问题，为简单起见，我们在此示例中未对其进行更改。确实可以在一次迭代中使用Ceres获得该问题的解决方案。还要注意，求解器在第一次迭代中确实得到误差接近0的最佳函数值。当我们讨论Ceres的收敛和参数设置时，我们将更详细地讨论这些问题。</p>
<h3 id="1-3-衍生"><a href="#1-3-衍生" class="headerlink" title="1.3 衍生"></a>1.3 衍生</h3><p>像大多数优化包一样，Ceres Solver依赖于在任意参数值下评估目标函数中每个项的值和导数。正确有效地这样做对于获得好结果至关重要。Ceres Solver提供了许多方法。我们现在考虑另外两种可能性：解析解和数值解。</p>
<h3 id="1-4-数值解"><a href="#1-4-数值解" class="headerlink" title="1.4 数值解"></a>1.4 数值解</h3><p>在某些情况下，无法定义模板<code>cost functor</code>，例如，当残差的评估涉及对您无法控制的库函数的调用时。在这种情况下，可以使用数值微分。用户定义了一个算子，它计算残差值并使用它构造<code>NumericDiffCostFunction</code>。例如，对于$f(x)=10-x ​$，相应的仿函数将是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumericDiffCostFunctor</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* <span class="keyword">const</span> x, <span class="keyword">double</span>* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>] = <span class="number">10.0</span> - x[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将其添加到<code>Problem</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CostFunction* cost_function =</span><br><span class="line">  <span class="keyword">new</span> NumericDiffCostFunction&lt;NumericDiffCostFunctor, ceres::CENTRAL, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> NumericDiffCostFunctor);</span><br><span class="line">problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, &amp;x);</span><br></pre></td></tr></table></figure>
<p>注意与我们使用<code>AutoDiffCostFunction</code>时的差异：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CostFunction* cost_function =</span><br><span class="line">    <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor);</span><br><span class="line">problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, &amp;x);</span><br></pre></td></tr></table></figure>
<p>除了额外的模板参数指示用于计算数值导数的有限差分方案的类型外，该构造看起来几乎与用<code>AutoDiffCostFunction</code>的构造相同。</p>
<p>一般来说，我们建议用<code>AutoDiffCostFunction</code>而不是<code>NumericDiffCostFunction</code>。C ++模板的使用使<code>AutoDiffCostFunction</code>很高效，而<code>NumericDiffCostFunction</code>很费时，而且容易出现数值错误，并导致收敛速度变慢。</p>
<h3 id="1-5-解析解"><a href="#1-5-解析解" class="headerlink" title="1.5 解析解"></a>1.5 解析解</h3><p>在某些情况下，使用<code>AutoDiffCostFunction</code>是不可行的。例如，解析解计算封闭形式导数比依赖于自动微分代码计算的更有效。在这种情况下，可以提供自己的残差和雅可比计算代码。为此，如果在编译时知道参数和残差的大小，请定义<code>CostFunction</code>或<code>SizedCostFunction</code>的子类。例如，下面是实现$ f(x)=10-x $的<code>SimpleCostFunction</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuadraticCostFunction</span> :</span> <span class="keyword">public</span> ceres::SizedCostFunction&lt;<span class="number">1</span>, <span class="number">1</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~QuadraticCostFunction() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Evaluate</span><span class="params">(<span class="keyword">double</span> <span class="keyword">const</span>* <span class="keyword">const</span>* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">double</span>* residuals,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">double</span>** jacobians)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> x = parameters[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    residuals[<span class="number">0</span>] = <span class="number">10</span> - x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the Jacobian if asked for.</span></span><br><span class="line">    <span class="keyword">if</span> (jacobians != <span class="literal">NULL</span> &amp;&amp; jacobians[<span class="number">0</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      jacobians[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>QuadraticCostFunction :: Evaluate</code>提供了输入数组<code>parameters</code>，输出数组<code>residuals</code>和<code>jacobians``。jacobians</code>数组是可选的，<code>Evaluate</code>应该检查它何时为非null，如果为null，则用剩余函数的导数值填充它。在这种情况下，由于残余函数是线性的，雅可比矩阵是常数。从上面的代码片段可以看出，实现<code>CostFunction</code>对象有点冗长。我们建议除非您有充分的理由自己管理雅可比计算，否则使用<code>AutoDiffCostFunction</code>或<code>NumericDiffCostFunction</code>来构造残差块。</p>
<p>计算数值解和解析解是迄今为止使用Ceres最复杂的部分，并且根据环境，用户可能需要更复杂的计算方法。一旦熟悉使用<code>NumericDiffCostFunction</code>和<code>AutoDiffCostFunction</code>，就可以继续查看<code>DynamicAutoDiffCostFunction</code>，<code>CostFunctionToFunctor</code>，<code>NumericDiffFunctor</code>和<code>ConditionedCostFunction</code>，以获得构建和计算成本函数的更高级方法。</p>
<h3 id="1-6-Powell’s-Function"><a href="#1-6-Powell’s-Function" class="headerlink" title="1.6 Powell’s Function"></a>1.6 Powell’s Function</h3><p>现在考虑一个稍微复杂的例子 ： Powell’s Function的最小化。设$x=\left[x_{1}, x_{2}, x_{3}, x_{4}\right]$和</p>
<script type="math/tex; mode=display">
\begin{array}{l}{f_{1}(x)=x_{1}+10 x_{2}} \\ {f_{2}(x)=\sqrt{5}\left(x_{3}-x_{4}\right)} \\ {f_{3}(x)=\left(x_{2}-2 x_{3}\right)^{2}} \\ {f_{4}(x)=\sqrt{10}\left(x_{1}-x_{4}\right)^{2}} \\ {F(x)=\left[f_{1}(x), f_{2}(x), f_{3}(x), f_{4}(x)\right]}\end{array}</script><p>$F(x)$是有四个参数的函数，有四个残差，我们希望找到$x$，使得$\frac{1}{2}|F(x)|^{2}$最小化。</p>
<p>同样，第一步是定义用于仿函数。以下是评估$f_{4}\left(x_{1}, x_{4}\right)​$的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F4</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1, <span class="keyword">const</span> T* <span class="keyword">const</span> x4, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>] = T(<span class="built_in">sqrt</span>(<span class="number">10.0</span>)) * (x1[<span class="number">0</span>] - x4[<span class="number">0</span>]) * (x1[<span class="number">0</span>] - x4[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似地，我们可以定义类<code>F1</code>，<code>F2</code>和<code>F3</code>来分别评估$ f_1(x1，x2)$，$ f_2(x3，x4)$和$ f_3(x2，x3)$ 。这样，问题可以构建如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x1 =  <span class="number">3.0</span>; <span class="keyword">double</span> x2 = <span class="number">-1.0</span>; <span class="keyword">double</span> x3 =  <span class="number">0.0</span>; <span class="keyword">double</span> x4 = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">Problem problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add residual terms to the problem using the using the autodiff</span></span><br><span class="line"><span class="comment">// wrapper to get the derivatives automatically.</span></span><br><span class="line">problem.AddResidualBlock(</span><br><span class="line">  <span class="keyword">new</span> AutoDiffCostFunction&lt;F1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F1), <span class="literal">NULL</span>, &amp;x1, &amp;x2);</span><br><span class="line">problem.AddResidualBlock(</span><br><span class="line">  <span class="keyword">new</span> AutoDiffCostFunction&lt;F2, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F2), <span class="literal">NULL</span>, &amp;x3, &amp;x4);</span><br><span class="line">problem.AddResidualBlock(</span><br><span class="line">  <span class="keyword">new</span> AutoDiffCostFunction&lt;F3, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F3), <span class="literal">NULL</span>, &amp;x2, &amp;x3)</span><br><span class="line">problem.AddResidualBlock(</span><br><span class="line">  <span class="keyword">new</span> AutoDiffCostFunction&lt;F4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F4), <span class="literal">NULL</span>, &amp;x1, &amp;x4);</span><br></pre></td></tr></table></figure>
<p>请注意，每个<code>ResidualBlock</code>仅取决于相应残留对象所依赖的两个参数，而不取决于所有四个参数。编译和运行程序后得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Initial x1 = 3, x2 = -1, x3 = 0, x4 = 1</span><br><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  1.075000e+02    0.00e+00    1.55e+02   0.00e+00   0.00e+00  1.00e+04       0    4.95e-04    2.30e-03</span><br><span class="line">   1  5.036190e+00    1.02e+02    2.00e+01   2.16e+00   9.53e-01  3.00e+04       1    4.39e-05    2.40e-03</span><br><span class="line">   2  3.148168e-01    4.72e+00    2.50e+00   6.23e-01   9.37e-01  9.00e+04       1    9.06e-06    2.43e-03</span><br><span class="line">   ………………省略部分</span><br><span class="line">  11  4.584044e-12    6.88e-11    1.86e-08   1.20e-03   9.37e-01  1.77e+09       1    6.91e-06    2.65e-03</span><br><span class="line">  12  2.865573e-13    4.30e-12    2.33e-09   6.02e-04   9.37e-01  5.31e+09       1    5.96e-06    2.67e-03</span><br><span class="line">  13  1.791438e-14    2.69e-13    2.91e-10   3.01e-04   9.37e-01  1.59e+10       1    7.15e-06    2.69e-03</span><br><span class="line"></span><br><span class="line">Ceres Solver v1.12.0 Solve Report</span><br><span class="line">----------------------------------</span><br><span class="line">                                     Original                  Reduced</span><br><span class="line">Parameter blocks                            4                        4</span><br><span class="line">Parameters                                  4                        4</span><br><span class="line">Residual blocks                             4                        4</span><br><span class="line">Residual                                    4                        4</span><br><span class="line"></span><br><span class="line">Minimizer                        TRUST_REGION</span><br><span class="line"></span><br><span class="line">Dense linear algebra library            EIGEN</span><br><span class="line">Trust region strategy     LEVENBERG_MARQUARDT</span><br><span class="line"></span><br><span class="line">                                        Given                     Used</span><br><span class="line">Linear solver                        DENSE_QR                 DENSE_QR</span><br><span class="line">Threads                                     1                        1</span><br><span class="line">Linear solver threads                       1                        1</span><br><span class="line"></span><br><span class="line">Cost:</span><br><span class="line">Initial                          1.075000e+02</span><br><span class="line">Final                            1.791438e-14</span><br><span class="line">Change                           1.075000e+02</span><br><span class="line"></span><br><span class="line">Minimizer iterations                       14</span><br><span class="line">Successful steps                           14</span><br><span class="line">Unsuccessful steps                          0</span><br><span class="line"></span><br><span class="line">Time (in seconds):</span><br><span class="line">Preprocessor                            0.002</span><br><span class="line"></span><br><span class="line">  Residual evaluation                   0.000</span><br><span class="line">  Jacobian evaluation                   0.000</span><br><span class="line">  Linear solver                         0.000</span><br><span class="line">Minimizer                               0.001</span><br><span class="line"></span><br><span class="line">Postprocessor                           0.000</span><br><span class="line">Total                                   0.005</span><br><span class="line"></span><br><span class="line">Termination:  CONVERGENCE (Gradient tolerance reached. Gradient max norm: 3.642190e-11 &lt;= 1.000000e-10)</span><br><span class="line"></span><br><span class="line">Final x1 = 0.000292189, x2 = -2.92189e-05, x3 = 4.79511e-05, x4 = 4.79511e-05</span><br></pre></td></tr></table></figure>
<p>很容易看出这个问题的最优解是$x_1 = 0，x_2 = 0，x_3 = 0，x_4 = 0$，目标函数值为0。在10次迭代中，Ceres找到了一个目标函数值为$4×10^{-12}​$的解。</p>
<p>上述问题所有代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: sameeragarwal@google.com (Sameer Agarwal)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An example program that minimizes Powell's singular function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   F = 1/2 (f1^2 + f2^2 + f3^2 + f4^2)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   f1 = x1 + 10*x2;</span></span><br><span class="line"><span class="comment">//   f2 = sqrt(5) * (x3 - x4)</span></span><br><span class="line"><span class="comment">//   f3 = (x2 - 2*x3)^2</span></span><br><span class="line"><span class="comment">//   f4 = sqrt(10) * (x1 - x4)^2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The starting values are x1 = 3, x2 = -1, x3 = 0, x4 = 1.</span></span><br><span class="line"><span class="comment">// The minimum is 0 at (x1, x2, x3, x4) = 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// From: Testing Unconstrained Optimization Software by Jorge J. More, Burton S.</span></span><br><span class="line"><span class="comment">// Garbow and Kenneth E. Hillstrom in ACM Transactions on Mathematical Software,</span></span><br><span class="line"><span class="comment">// Vol 7(1), March 1981.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gflags/gflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span></span></span><br><span class="line"><span class="keyword">using</span> ceres::AutoDiffCostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::CostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::Problem;</span><br><span class="line"><span class="keyword">using</span> ceres::Solver;</span><br><span class="line"><span class="keyword">using</span> ceres::Solve;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F1</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f1 = x1 + 10 * x2;</span></span><br><span class="line">    residual[<span class="number">0</span>] = x1[<span class="number">0</span>] + <span class="number">10.0</span> * x2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F2</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x3,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x4,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f2 = sqrt(5) (x3 - x4)</span></span><br><span class="line">    residual[<span class="number">0</span>] = <span class="built_in">sqrt</span>(<span class="number">5.0</span>) * (x3[<span class="number">0</span>] - x4[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F3</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x3,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f3 = (x2 - 2 x3)^2</span></span><br><span class="line">    residual[<span class="number">0</span>] = (x2[<span class="number">0</span>] - <span class="number">2.0</span> * x3[<span class="number">0</span>]) * (x2[<span class="number">0</span>] - <span class="number">2.0</span> * x3[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F4</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x4,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f4 = sqrt(10) (x1 - x4)^2</span></span><br><span class="line">    residual[<span class="number">0</span>] = <span class="built_in">sqrt</span>(<span class="number">10.0</span>) * (x1[<span class="number">0</span>] - x4[<span class="number">0</span>]) * (x1[<span class="number">0</span>] - x4[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">DEFINE_string(minimizer, <span class="string">"trust_region"</span>,</span><br><span class="line">              <span class="string">"Minimizer type to use, choices are: line_search &amp; trust_region"</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  CERES_GFLAGS_NAMESPACE::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">double</span> x1 =  <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">double</span> x2 = <span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">double</span> x3 =  <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">double</span> x4 =  <span class="number">1.0</span>;</span><br><span class="line">  Problem problem;</span><br><span class="line">  <span class="comment">// Add residual terms to the problem using the using the autodiff</span></span><br><span class="line">  <span class="comment">// wrapper to get the derivatives automatically. The parameters, x1 through</span></span><br><span class="line">  <span class="comment">// x4, are modified in place.</span></span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F1),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x1, &amp;x2);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F2, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F2),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x3, &amp;x4);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F3, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F3),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x2, &amp;x3);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F4),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x1, &amp;x4);</span><br><span class="line">  Solver::Options options;</span><br><span class="line">  LOG_IF(FATAL, !ceres::StringToMinimizerType(FLAGS_minimizer,</span><br><span class="line">                                              &amp;options.minimizer_type))</span><br><span class="line">      &lt;&lt; <span class="string">"Invalid minimizer: "</span> &lt;&lt; FLAGS_minimizer</span><br><span class="line">      &lt;&lt; <span class="string">", valid options are: trust_region and line_search."</span>;</span><br><span class="line">  options.max_num_iterations = <span class="number">100</span>;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial x1 = "</span> &lt;&lt; x1</span><br><span class="line">            &lt;&lt; <span class="string">", x2 = "</span> &lt;&lt; x2</span><br><span class="line">            &lt;&lt; <span class="string">", x3 = "</span> &lt;&lt; x3</span><br><span class="line">            &lt;&lt; <span class="string">", x4 = "</span> &lt;&lt; x4</span><br><span class="line">            &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">// Run the solver!</span></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final x1 = "</span> &lt;&lt; x1</span><br><span class="line">            &lt;&lt; <span class="string">", x2 = "</span> &lt;&lt; x2</span><br><span class="line">            &lt;&lt; <span class="string">", x3 = "</span> &lt;&lt; x3</span><br><span class="line">            &lt;&lt; <span class="string">", x4 = "</span> &lt;&lt; x4</span><br><span class="line">            &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-曲线拟合"><a href="#1-7-曲线拟合" class="headerlink" title="1.7 曲线拟合"></a>1.7 曲线拟合</h3><p>我们到目前为止看到的例子是没有数据的简单优化问题。最小二乘和非线性最小二乘分析的最初目的是拟合数据曲线。我们现在考虑这样一个问题，它对曲线$y=e^{0.3 x+0.1}$进行采样并添加标准偏差$σ=0.2​$的高斯噪声而生成的数据。让我们将一些数据拟合到曲线中</p>
<script type="math/tex; mode=display">
y=e^{m x+c}</script><p>我们首先定义一个模板化对象来评估残差。每次观察都会有残差。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExponentialResidual</span> &#123;</span></span><br><span class="line">  ExponentialResidual(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">      : x_(x), y_(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> m, <span class="keyword">const</span> T* <span class="keyword">const</span> c, T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>] = T(y_) - <span class="built_in">exp</span>(m[<span class="number">0</span>] * T(x_) + c[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Observations for a sample.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> y_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设观察结果是一个称为<code>data</code>的$2n​$大小的数组，该问题的构造是为每个观察创建一个<code>CostFunction</code>的简单问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> m = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> c = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">Problem problem;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kNumObservations; ++i) &#123;</span><br><span class="line">  CostFunction* cost_function =</span><br><span class="line">       <span class="keyword">new</span> AutoDiffCostFunction&lt;ExponentialResidual, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(</span><br><span class="line">           <span class="keyword">new</span> ExponentialResidual(data[<span class="number">2</span> * i], data[<span class="number">2</span> * i + <span class="number">1</span>]));</span><br><span class="line">  problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, &amp;m, &amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   0  1.211734e+02    0.00e+00    3.61e+02   0.00e+00   0.00e+00  1.00e+04       0    5.34e-04    2.56e-03</span><br><span class="line">   1  1.211734e+02   -2.21e+03    0.00e+00   7.52e-01  -1.87e+01  5.00e+03       1    4.29e-05    3.25e-03</span><br><span class="line">   2  1.211734e+02   -2.21e+03    0.00e+00   7.51e-01  -1.86e+01  1.25e+03       1    1.10e-05    3.28e-03</span><br><span class="line">  …………省略</span><br><span class="line">  12  1.056795e+00    6.47e-03    1.18e-01   1.47e-02   1.00e+00  6.67e+02       1    2.10e-05    3.64e-03</span><br><span class="line">  13  1.056751e+00    4.39e-05    3.79e-03   1.28e-03   1.00e+00  2.00e+03       1    2.10e-05    3.68e-03</span><br><span class="line">Ceres Solver Report: Iterations: 13, Initial cost: 1.211734e+02, Final cost: 1.056751e+00, Termination: CONVERGENCE</span><br><span class="line">Initial m: 0 c: 0</span><br><span class="line">Final   m: 0.291861 c: 0.131439</span><br></pre></td></tr></table></figure>
<p>从参数值$m = 0，c = 0$开始，初始目标函数值为$121.173121.173$ 。Ceres找到一个解$m = 0.291861，c = 0.131439$，此时目标函数值$1.056751.05675$。这些值与原始模型$m = 0.3，c = 0.1$的参数略有不同，但误差并不大，是符合预期的。当从噪声数据重建曲线时，我们期望看到这种偏差。实际上，如果你要评估$m = 0.3，c = 0.1$的目标函数，其实拟合值更差，目标函数值为1.0824251.082425。下图说明了拟合度：</p>
<p><img src="http://ceres-solver.org/_images/least_squares_fit.png" alt="_images/least_squares_fit.png"></p>
<p>下面为曲线拟合的完整代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span></span></span><br><span class="line"><span class="keyword">using</span> ceres::AutoDiffCostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::CostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::Problem;</span><br><span class="line"><span class="keyword">using</span> ceres::Solver;</span><br><span class="line"><span class="keyword">using</span> ceres::Solve;</span><br><span class="line"><span class="comment">// Data generated using the following octave code.</span></span><br><span class="line"><span class="comment">//   randn('seed', 23497);</span></span><br><span class="line"><span class="comment">//   m = 0.3;</span></span><br><span class="line"><span class="comment">//   c = 0.1;</span></span><br><span class="line"><span class="comment">//   x=[0:0.075:5];</span></span><br><span class="line"><span class="comment">//   y = exp(m * x + c);</span></span><br><span class="line"><span class="comment">//   noise = randn(size(x)) * 0.2;</span></span><br><span class="line"><span class="comment">//   y_observed = y + noise;</span></span><br><span class="line"><span class="comment">//   data = [x', y_observed'];</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumObservations = <span class="number">67</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.000000e+00</span>, <span class="number">1.133898e+00</span>,</span><br><span class="line">  <span class="number">7.500000e-02</span>, <span class="number">1.334902e+00</span>,</span><br><span class="line">  <span class="number">1.500000e-01</span>, <span class="number">1.213546e+00</span>,</span><br><span class="line">  <span class="number">2.250000e-01</span>, <span class="number">1.252016e+00</span>,</span><br><span class="line">  <span class="number">3.000000e-01</span>, <span class="number">1.392265e+00</span>,</span><br><span class="line">  <span class="number">3.750000e-01</span>, <span class="number">1.314458e+00</span>,</span><br><span class="line">  <span class="number">4.500000e-01</span>, <span class="number">1.472541e+00</span>,</span><br><span class="line">  <span class="number">5.250000e-01</span>, <span class="number">1.536218e+00</span>,</span><br><span class="line">  <span class="number">6.000000e-01</span>, <span class="number">1.355679e+00</span>,</span><br><span class="line">  <span class="number">6.750000e-01</span>, <span class="number">1.463566e+00</span>,</span><br><span class="line">  <span class="number">7.500000e-01</span>, <span class="number">1.490201e+00</span>,</span><br><span class="line">  <span class="number">8.250000e-01</span>, <span class="number">1.658699e+00</span>,</span><br><span class="line">  <span class="number">9.000000e-01</span>, <span class="number">1.067574e+00</span>,</span><br><span class="line">  <span class="number">9.750000e-01</span>, <span class="number">1.464629e+00</span>,</span><br><span class="line">  <span class="number">1.050000e+00</span>, <span class="number">1.402653e+00</span>,</span><br><span class="line">  <span class="number">1.125000e+00</span>, <span class="number">1.713141e+00</span>,</span><br><span class="line">  <span class="number">1.200000e+00</span>, <span class="number">1.527021e+00</span>,</span><br><span class="line">  <span class="number">1.275000e+00</span>, <span class="number">1.702632e+00</span>,</span><br><span class="line">  <span class="number">1.350000e+00</span>, <span class="number">1.423899e+00</span>,</span><br><span class="line">  <span class="number">1.425000e+00</span>, <span class="number">1.543078e+00</span>,</span><br><span class="line">  <span class="number">1.500000e+00</span>, <span class="number">1.664015e+00</span>,</span><br><span class="line">  <span class="number">1.575000e+00</span>, <span class="number">1.732484e+00</span>,</span><br><span class="line">  <span class="number">1.650000e+00</span>, <span class="number">1.543296e+00</span>,</span><br><span class="line">  <span class="number">1.725000e+00</span>, <span class="number">1.959523e+00</span>,</span><br><span class="line">  <span class="number">1.800000e+00</span>, <span class="number">1.685132e+00</span>,</span><br><span class="line">  <span class="number">1.875000e+00</span>, <span class="number">1.951791e+00</span>,</span><br><span class="line">  <span class="number">1.950000e+00</span>, <span class="number">2.095346e+00</span>,</span><br><span class="line">  <span class="number">2.025000e+00</span>, <span class="number">2.361460e+00</span>,</span><br><span class="line">  <span class="number">2.100000e+00</span>, <span class="number">2.169119e+00</span>,</span><br><span class="line">  <span class="number">2.175000e+00</span>, <span class="number">2.061745e+00</span>,</span><br><span class="line">  <span class="number">2.250000e+00</span>, <span class="number">2.178641e+00</span>,</span><br><span class="line">  <span class="number">2.325000e+00</span>, <span class="number">2.104346e+00</span>,</span><br><span class="line">  <span class="number">2.400000e+00</span>, <span class="number">2.584470e+00</span>,</span><br><span class="line">  <span class="number">2.475000e+00</span>, <span class="number">1.914158e+00</span>,</span><br><span class="line">  <span class="number">2.550000e+00</span>, <span class="number">2.368375e+00</span>,</span><br><span class="line">  <span class="number">2.625000e+00</span>, <span class="number">2.686125e+00</span>,</span><br><span class="line">  <span class="number">2.700000e+00</span>, <span class="number">2.712395e+00</span>,</span><br><span class="line">  <span class="number">2.775000e+00</span>, <span class="number">2.499511e+00</span>,</span><br><span class="line">  <span class="number">2.850000e+00</span>, <span class="number">2.558897e+00</span>,</span><br><span class="line">  <span class="number">2.925000e+00</span>, <span class="number">2.309154e+00</span>,</span><br><span class="line">  <span class="number">3.000000e+00</span>, <span class="number">2.869503e+00</span>,</span><br><span class="line">  <span class="number">3.075000e+00</span>, <span class="number">3.116645e+00</span>,</span><br><span class="line">  <span class="number">3.150000e+00</span>, <span class="number">3.094907e+00</span>,</span><br><span class="line">  <span class="number">3.225000e+00</span>, <span class="number">2.471759e+00</span>,</span><br><span class="line">  <span class="number">3.300000e+00</span>, <span class="number">3.017131e+00</span>,</span><br><span class="line">  <span class="number">3.375000e+00</span>, <span class="number">3.232381e+00</span>,</span><br><span class="line">  <span class="number">3.450000e+00</span>, <span class="number">2.944596e+00</span>,</span><br><span class="line">  <span class="number">3.525000e+00</span>, <span class="number">3.385343e+00</span>,</span><br><span class="line">  <span class="number">3.600000e+00</span>, <span class="number">3.199826e+00</span>,</span><br><span class="line">  <span class="number">3.675000e+00</span>, <span class="number">3.423039e+00</span>,</span><br><span class="line">  <span class="number">3.750000e+00</span>, <span class="number">3.621552e+00</span>,</span><br><span class="line">  <span class="number">3.825000e+00</span>, <span class="number">3.559255e+00</span>,</span><br><span class="line">  <span class="number">3.900000e+00</span>, <span class="number">3.530713e+00</span>,</span><br><span class="line">  <span class="number">3.975000e+00</span>, <span class="number">3.561766e+00</span>,</span><br><span class="line">  <span class="number">4.050000e+00</span>, <span class="number">3.544574e+00</span>,</span><br><span class="line">  <span class="number">4.125000e+00</span>, <span class="number">3.867945e+00</span>,</span><br><span class="line">  <span class="number">4.200000e+00</span>, <span class="number">4.049776e+00</span>,</span><br><span class="line">  <span class="number">4.275000e+00</span>, <span class="number">3.885601e+00</span>,</span><br><span class="line">  <span class="number">4.350000e+00</span>, <span class="number">4.110505e+00</span>,</span><br><span class="line">  <span class="number">4.425000e+00</span>, <span class="number">4.345320e+00</span>,</span><br><span class="line">  <span class="number">4.500000e+00</span>, <span class="number">4.161241e+00</span>,</span><br><span class="line">  <span class="number">4.575000e+00</span>, <span class="number">4.363407e+00</span>,</span><br><span class="line">  <span class="number">4.650000e+00</span>, <span class="number">4.161576e+00</span>,</span><br><span class="line">  <span class="number">4.725000e+00</span>, <span class="number">4.619728e+00</span>,</span><br><span class="line">  <span class="number">4.800000e+00</span>, <span class="number">4.737410e+00</span>,</span><br><span class="line">  <span class="number">4.875000e+00</span>, <span class="number">4.727863e+00</span>,</span><br><span class="line">  <span class="number">4.950000e+00</span>, <span class="number">4.669206e+00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExponentialResidual</span> &#123;</span></span><br><span class="line">  ExponentialResidual(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span><br><span class="line">      : x_(x), y_(y) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> m,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>] = y_ - <span class="built_in">exp</span>(m[<span class="number">0</span>] * x_ + c[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">double</span> m = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">double</span> c = <span class="number">0.0</span>;</span><br><span class="line">  Problem problem;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kNumObservations; ++i) &#123;</span><br><span class="line">    problem.AddResidualBlock(</span><br><span class="line">        <span class="keyword">new</span> AutoDiffCostFunction&lt;ExponentialResidual, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(</span><br><span class="line">            <span class="keyword">new</span> ExponentialResidual(data[<span class="number">2</span> * i], data[<span class="number">2</span> * i + <span class="number">1</span>])),</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;m, &amp;c);</span><br><span class="line">  &#125;</span><br><span class="line">  Solver::Options options;</span><br><span class="line">  options.max_num_iterations = <span class="number">25</span>;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.BriefReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial m: "</span> &lt;&lt; <span class="number">0.0</span> &lt;&lt; <span class="string">" c: "</span> &lt;&lt; <span class="number">0.0</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final   m: "</span> &lt;&lt; m &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-鲁棒曲线拟合"><a href="#1-8-鲁棒曲线拟合" class="headerlink" title="1.8 鲁棒曲线拟合"></a>1.8 鲁棒曲线拟合</h3><p>现在假设我们给出的数据有一些异常值，即我们有一些不遵守噪声模型的点。如果我们使用上面的代码来拟合这些数据，我们会得到如下所示的拟合。注意拟合曲线如何偏离真实值。</p>
<p><img src="http://ceres-solver.org/_images/non_robust_least_squares_fit.png" alt="_images/non_robust_least_squares_fit.png"></p>
<p>为了处理异常值，常用方法是使用<code>LossFunction</code>。损失函数减少具有高残差的残差块（即异常值）的影响，通常是与异常值相对应的残差。为了将损失函数与残差块相关联，我们把</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem.AddResidualBlock(cost_function, <span class="literal">NULL</span> , &amp;m, &amp;c);</span><br></pre></td></tr></table></figure>
<p>改为了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem.AddResidualBlock(cost_function, <span class="keyword">new</span> CauchyLoss(<span class="number">0.5</span>) , &amp;m, &amp;c);</span><br></pre></td></tr></table></figure>
<p><code>CauchyLoss</code>是Ceres Solver附带的损失函数之一。参数$0.5$指定损失函数的比例。结果，我们得到了下面的拟合。注意拟合曲线如何向后靠近真实值曲线移动。</p>
<p><img src="http://ceres-solver.org/_images/robust_least_squares_fit.png" alt="_images/robust_least_squares_fit.png"></p>
<h3 id="1-9-光束平差法"><a href="#1-9-光束平差法" class="headerlink" title="1.9 光束平差法"></a>1.9 光束平差法</h3><p>作者写Ceres库的主要原因之一是解决大规模的光束平差问题。</p>
<p>给定一组图像特征的位置和对应关系，光束平差的目标是找到最小化重投影误差的3D点位置和相机参数。该优化问题通常被表述为非线性最小二乘问题，其中误差是观察到的特征位置与相机图像平面上的相应3D点的投影之间的差的平方$L2$范数。Ceres比较好的支持解决光束平差问题。</p>
<p>让我们使用BAL数据集中解决问题。</p>
<p>通常的第一步是定义一个计算重投影误差/残差的模板化仿函数（templated functor）。仿函数的结构类似于<code>ExponentialResidual</code>，因为该对象的实例负责每个图像。</p>
<p>BAL问题中的每个残差取决于三维点和有9个参数的相机。定义摄像机的9个参数是：三个用于旋转（作为Rodriques的轴角矢量），三个用于平移，一个用于焦距，两个用于径向畸变。可以在<a href="http://phototour.cs.washington.edu/bundler/" target="_blank" rel="noopener">Bundler主页</a>和<a href="http://grail.cs.washington.edu/projects/bal/" target="_blank" rel="noopener">BAL主页</a>上找到此相机型号的详细信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnavelyReprojectionError</span> &#123;</span></span><br><span class="line">  SnavelyReprojectionError(<span class="keyword">double</span> observed_x, <span class="keyword">double</span> observed_y)</span><br><span class="line">      : observed_x(observed_x), observed_y(observed_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> T* <span class="keyword">const</span> point,</span></span></span><br><span class="line"><span class="function"><span class="params">                  T* residuals)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// camera[0,1,2] are the angle-axis rotation.</span></span><br><span class="line">    T p[<span class="number">3</span>];</span><br><span class="line">    ceres::AngleAxisRotatePoint(camera, point, p);</span><br><span class="line">    <span class="comment">// camera[3,4,5] are the translation.</span></span><br><span class="line">    p[<span class="number">0</span>] += camera[<span class="number">3</span>]; p[<span class="number">1</span>] += camera[<span class="number">4</span>]; p[<span class="number">2</span>] += camera[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the center of distortion. The sign change comes from</span></span><br><span class="line">    <span class="comment">// the camera model that Noah Snavely's Bundler assumes, whereby</span></span><br><span class="line">    <span class="comment">// the camera coordinate system has a negative z axis.</span></span><br><span class="line">    T xp = - p[<span class="number">0</span>] / p[<span class="number">2</span>];</span><br><span class="line">    T yp = - p[<span class="number">1</span>] / p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply second and fourth order radial distortion.</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; l1 = camera[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">const</span> T&amp; l2 = camera[<span class="number">8</span>];</span><br><span class="line">    T r2 = xp*xp + yp*yp;</span><br><span class="line">    T distortion = T(<span class="number">1.0</span>) + r2  * (l1 + l2  * r2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute final projected point position.</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; focal = camera[<span class="number">6</span>];</span><br><span class="line">    T predicted_x = focal * distortion * xp;</span><br><span class="line">    T predicted_y = focal * distortion * yp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The error is the difference between the predicted and observed position.</span></span><br><span class="line">    residuals[<span class="number">0</span>] = predicted_x - T(observed_x);</span><br><span class="line">    residuals[<span class="number">1</span>] = predicted_y - T(observed_y);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Factory to hide the construction of the CostFunction object from</span></span><br><span class="line">   <span class="comment">// the client code.</span></span><br><span class="line">   <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> observed_x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">double</span> observed_y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;SnavelyReprojectionError, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>&gt;(</span><br><span class="line">                 <span class="keyword">new</span> SnavelyReprojectionError(observed_x, observed_y)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> observed_x;</span><br><span class="line">  <span class="keyword">double</span> observed_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请注意，与之前的示例不同，这是一个不平凡的函数，计算其解析雅可比行列式有点痛苦。自动求导会使程序编写更加简单。函数<code>AngleAxisRotatePoint（）</code>和其他用于操作旋转的函数可以在include / ceres / rotation.h中找到。</p>
<p>给定这个仿函数，光束平差问题可以构造如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ceres::Problem problem;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem.num_observations(); ++i) &#123;</span><br><span class="line">  ceres::CostFunction* cost_function =</span><br><span class="line">      SnavelyReprojectionError::Create(</span><br><span class="line">           bal_problem.observations()[<span class="number">2</span> * i + <span class="number">0</span>],</span><br><span class="line">           bal_problem.observations()[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">  problem.AddResidualBlock(cost_function,</span><br><span class="line">                           <span class="literal">NULL</span> <span class="comment">/* squared loss */</span>,</span><br><span class="line">                           bal_problem.mutable_camera_for_observation(i),</span><br><span class="line">                           bal_problem.mutable_point_for_observation(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，光束平差问题的构造与曲线拟合示例非常相似 ， 每观察一次就把一项误差添加到目标函数中。由于这是一个很大的稀疏问题（对于<code>DENSE_QR</code>方法是很大啦），解决这个问题的一种方法是将<code>Solver :: Options :: linear_solver_type</code>设置为<code>SPARSE_NORMAL_CHOLESKY</code>并调用<code>Solve（）</code>。虽然这是一个合理的事情，但是光束平差问题有一个特殊的稀疏结构，可以利用它来更有效地解决它们。Ceres为此任务提供了三种专用求解器（统称为基于Schur的求解器）。示例代码使用最简单的<code>DENSE_SCHUR</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ceres::Solver::Options options;</span><br><span class="line">options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">ceres::Solver::Summary summary;</span><br><span class="line">ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>
<p>下面代码是一个更复杂的光束平差示例，它演示了如何使用Ceres的更高级功能，包括各种线性求解器，强大的损失函数和本地参数化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An example of solving a dynamically sized problem with various</span></span><br><span class="line"><span class="comment">// solvers and loss functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For a simpler bare bones example of doing bundle adjustment with</span></span><br><span class="line"><span class="comment">// Ceres, please see simple_bundle_adjuster.cc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This example will not compile without gflags and SuiteSparse.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The problem being solved here is known as a Bundle Adjustment</span></span><br><span class="line"><span class="comment">// problem in computer vision. Given a set of 3d points X_1, ..., X_n,</span></span><br><span class="line"><span class="comment">// a set of cameras P_1, ..., P_m. If the point X_i is visible in</span></span><br><span class="line"><span class="comment">// image j, then there is a 2D observation u_ij that is the expected</span></span><br><span class="line"><span class="comment">// projection of X_i using P_j. The aim of this optimization is to</span></span><br><span class="line"><span class="comment">// find values of X_i and P_j such that the reprojection error</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    E(X,P) =  sum_ij  |u_ij - P_j X_i|^2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// is minimized.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The problem used here comes from a collection of bundle adjustment</span></span><br><span class="line"><span class="comment">// problems published at University of Washington.</span></span><br><span class="line"><span class="comment">// http://grail.cs.washington.edu/projects/bal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bal_problem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gflags/gflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"snavely_reprojection_error.h"</span></span></span><br><span class="line">DEFINE_string(input, <span class="string">""</span>, <span class="string">"Input File name"</span>);</span><br><span class="line">DEFINE_string(trust_region_strategy, <span class="string">"levenberg_marquardt"</span>,</span><br><span class="line">              <span class="string">"Options are: levenberg_marquardt, dogleg."</span>);</span><br><span class="line">DEFINE_string(dogleg, <span class="string">"traditional_dogleg"</span>, <span class="string">"Options are: traditional_dogleg,"</span></span><br><span class="line">              <span class="string">"subspace_dogleg."</span>);</span><br><span class="line">DEFINE_bool(inner_iterations, <span class="literal">false</span>, <span class="string">"Use inner iterations to non-linearly "</span></span><br><span class="line">            <span class="string">"refine each successful trust region step."</span>);</span><br><span class="line">DEFINE_string(blocks_for_inner_iterations, <span class="string">"automatic"</span>, <span class="string">"Options are: "</span></span><br><span class="line">            <span class="string">"automatic, cameras, points, cameras,points, points,cameras"</span>);</span><br><span class="line">DEFINE_string(linear_solver, <span class="string">"sparse_schur"</span>, <span class="string">"Options are: "</span></span><br><span class="line">              <span class="string">"sparse_schur, dense_schur, iterative_schur, sparse_normal_cholesky, "</span></span><br><span class="line">              <span class="string">"dense_qr, dense_normal_cholesky and cgnr."</span>);</span><br><span class="line">DEFINE_bool(explicit_schur_complement, <span class="literal">false</span>, <span class="string">"If using ITERATIVE_SCHUR "</span></span><br><span class="line">            <span class="string">"then explicitly compute the Schur complement."</span>);</span><br><span class="line">DEFINE_string(preconditioner, <span class="string">"jacobi"</span>, <span class="string">"Options are: "</span></span><br><span class="line">              <span class="string">"identity, jacobi, schur_jacobi, cluster_jacobi, "</span></span><br><span class="line">              <span class="string">"cluster_tridiagonal."</span>);</span><br><span class="line">DEFINE_string(visibility_clustering, <span class="string">"canonical_views"</span>,</span><br><span class="line">              <span class="string">"single_linkage, canonical_views"</span>);</span><br><span class="line">DEFINE_string(sparse_linear_algebra_library, <span class="string">"suite_sparse"</span>,</span><br><span class="line">              <span class="string">"Options are: suite_sparse and cx_sparse."</span>);</span><br><span class="line">DEFINE_string(dense_linear_algebra_library, <span class="string">"eigen"</span>,</span><br><span class="line">              <span class="string">"Options are: eigen and lapack."</span>);</span><br><span class="line">DEFINE_string(ordering, <span class="string">"automatic"</span>, <span class="string">"Options are: automatic, user."</span>);</span><br><span class="line">DEFINE_bool(use_quaternions, <span class="literal">false</span>, <span class="string">"If true, uses quaternions to represent "</span></span><br><span class="line">            <span class="string">"rotations. If false, angle axis is used."</span>);</span><br><span class="line">DEFINE_bool(use_local_parameterization, <span class="literal">false</span>, <span class="string">"For quaternions, use a local "</span></span><br><span class="line">            <span class="string">"parameterization."</span>);</span><br><span class="line">DEFINE_bool(robustify, <span class="literal">false</span>, <span class="string">"Use a robust loss function."</span>);</span><br><span class="line">DEFINE_double(eta, <span class="number">1e-2</span>, <span class="string">"Default value for eta. Eta determines the "</span></span><br><span class="line">             <span class="string">"accuracy of each linear solve of the truncated newton step. "</span></span><br><span class="line">             <span class="string">"Changing this parameter can affect solve performance."</span>);</span><br><span class="line">DEFINE_int32(num_threads, <span class="number">1</span>, <span class="string">"Number of threads."</span>);</span><br><span class="line">DEFINE_int32(num_iterations, <span class="number">5</span>, <span class="string">"Number of iterations."</span>);</span><br><span class="line">DEFINE_double(max_solver_time, <span class="number">1e32</span>, <span class="string">"Maximum solve time in seconds."</span>);</span><br><span class="line">DEFINE_bool(nonmonotonic_steps, <span class="literal">false</span>, <span class="string">"Trust region algorithm can use"</span></span><br><span class="line">            <span class="string">" nonmonotic steps."</span>);</span><br><span class="line">DEFINE_double(rotation_sigma, <span class="number">0.0</span>, <span class="string">"Standard deviation of camera rotation "</span></span><br><span class="line">              <span class="string">"perturbation."</span>);</span><br><span class="line">DEFINE_double(translation_sigma, <span class="number">0.0</span>, <span class="string">"Standard deviation of the camera "</span></span><br><span class="line">              <span class="string">"translation perturbation."</span>);</span><br><span class="line">DEFINE_double(point_sigma, <span class="number">0.0</span>, <span class="string">"Standard deviation of the point "</span></span><br><span class="line">              <span class="string">"perturbation."</span>);</span><br><span class="line">DEFINE_int32(random_seed, <span class="number">38401</span>, <span class="string">"Random seed used to set the state "</span></span><br><span class="line">             <span class="string">"of the pseudo random number generator used to generate "</span></span><br><span class="line">             <span class="string">"the pertubations."</span>);</span><br><span class="line">DEFINE_bool(line_search, <span class="literal">false</span>, <span class="string">"Use a line search instead of trust region "</span></span><br><span class="line">            <span class="string">"algorithm."</span>);</span><br><span class="line">DEFINE_bool(mixed_precision_solves, <span class="literal">false</span>, <span class="string">"Use mixed precision solves."</span>);</span><br><span class="line">DEFINE_int32(max_num_refinement_iterations, <span class="number">0</span>, <span class="string">"Iterative refinement iterations"</span>);</span><br><span class="line">DEFINE_string(initial_ply, <span class="string">""</span>, <span class="string">"Export the BAL file data as a PLY file."</span>);</span><br><span class="line">DEFINE_string(final_ply, <span class="string">""</span>, <span class="string">"Export the refined BAL file data as a PLY "</span></span><br><span class="line">              <span class="string">"file."</span>);</span><br><span class="line"><span class="keyword">namespace</span> ceres &#123;</span><br><span class="line"><span class="keyword">namespace</span> examples &#123;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLinearSolver</span><span class="params">(Solver::Options* options)</span> </span>&#123;</span><br><span class="line">  CHECK(StringToLinearSolverType(FLAGS_linear_solver,</span><br><span class="line">                                 &amp;options-&gt;linear_solver_type));</span><br><span class="line">  CHECK(StringToPreconditionerType(FLAGS_preconditioner,</span><br><span class="line">                                   &amp;options-&gt;preconditioner_type));</span><br><span class="line">  CHECK(StringToVisibilityClusteringType(FLAGS_visibility_clustering,</span><br><span class="line">                                         &amp;options-&gt;visibility_clustering_type));</span><br><span class="line">  CHECK(StringToSparseLinearAlgebraLibraryType(</span><br><span class="line">            FLAGS_sparse_linear_algebra_library,</span><br><span class="line">            &amp;options-&gt;sparse_linear_algebra_library_type));</span><br><span class="line">  CHECK(StringToDenseLinearAlgebraLibraryType(</span><br><span class="line">            FLAGS_dense_linear_algebra_library,</span><br><span class="line">            &amp;options-&gt;dense_linear_algebra_library_type));</span><br><span class="line">  options-&gt;use_explicit_schur_complement = FLAGS_explicit_schur_complement;</span><br><span class="line">  options-&gt;use_mixed_precision_solves = FLAGS_mixed_precision_solves;</span><br><span class="line">  options-&gt;max_num_refinement_iterations = FLAGS_max_num_refinement_iterations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetOrdering</span><span class="params">(BALProblem* bal_problem, Solver::Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_points = bal_problem-&gt;num_points();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> point_block_size = bal_problem-&gt;point_block_size();</span><br><span class="line">  <span class="keyword">double</span>* points = bal_problem-&gt;mutable_points();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_cameras = bal_problem-&gt;num_cameras();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> camera_block_size = bal_problem-&gt;camera_block_size();</span><br><span class="line">  <span class="keyword">double</span>* cameras = bal_problem-&gt;mutable_cameras();</span><br><span class="line">  <span class="keyword">if</span> (options-&gt;use_inner_iterations) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FLAGS_blocks_for_inner_iterations == <span class="string">"cameras"</span>) &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">"Camera blocks for inner iterations"</span>;</span><br><span class="line">      options-&gt;inner_iteration_ordering.reset(<span class="keyword">new</span> ParameterBlockOrdering);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i) &#123;</span><br><span class="line">        options-&gt;inner_iteration_ordering-&gt;AddElementToGroup(cameras + camera_block_size * i, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAGS_blocks_for_inner_iterations == <span class="string">"points"</span>) &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">"Point blocks for inner iterations"</span>;</span><br><span class="line">      options-&gt;inner_iteration_ordering.reset(<span class="keyword">new</span> ParameterBlockOrdering);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i) &#123;</span><br><span class="line">        options-&gt;inner_iteration_ordering-&gt;AddElementToGroup(points + point_block_size * i, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAGS_blocks_for_inner_iterations == <span class="string">"cameras,points"</span>) &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">"Camera followed by point blocks for inner iterations"</span>;</span><br><span class="line">      options-&gt;inner_iteration_ordering.reset(<span class="keyword">new</span> ParameterBlockOrdering);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i) &#123;</span><br><span class="line">        options-&gt;inner_iteration_ordering-&gt;AddElementToGroup(cameras + camera_block_size * i, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i) &#123;</span><br><span class="line">        options-&gt;inner_iteration_ordering-&gt;AddElementToGroup(points + point_block_size * i, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAGS_blocks_for_inner_iterations == <span class="string">"points,cameras"</span>) &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">"Point followed by camera blocks for inner iterations"</span>;</span><br><span class="line">      options-&gt;inner_iteration_ordering.reset(<span class="keyword">new</span> ParameterBlockOrdering);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i) &#123;</span><br><span class="line">        options-&gt;inner_iteration_ordering-&gt;AddElementToGroup(cameras + camera_block_size * i, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i) &#123;</span><br><span class="line">        options-&gt;inner_iteration_ordering-&gt;AddElementToGroup(points + point_block_size * i, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAGS_blocks_for_inner_iterations == <span class="string">"automatic"</span>) &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">"Choosing automatic blocks for inner iterations"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG(FATAL) &lt;&lt; <span class="string">"Unknown block type for inner iterations: "</span></span><br><span class="line">                 &lt;&lt; FLAGS_blocks_for_inner_iterations;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Bundle adjustment problems have a sparsity structure that makes</span></span><br><span class="line">  <span class="comment">// them amenable to more specialized and much more efficient</span></span><br><span class="line">  <span class="comment">// solution strategies. The SPARSE_SCHUR, DENSE_SCHUR and</span></span><br><span class="line">  <span class="comment">// ITERATIVE_SCHUR solvers make use of this specialized</span></span><br><span class="line">  <span class="comment">// structure.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This can either be done by specifying Options::ordering_type =</span></span><br><span class="line">  <span class="comment">// ceres::SCHUR, in which case Ceres will automatically determine</span></span><br><span class="line">  <span class="comment">// the right ParameterBlock ordering, or by manually specifying a</span></span><br><span class="line">  <span class="comment">// suitable ordering vector and defining</span></span><br><span class="line">  <span class="comment">// Options::num_eliminate_blocks.</span></span><br><span class="line">  <span class="keyword">if</span> (FLAGS_ordering == <span class="string">"automatic"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ceres::ParameterBlockOrdering* ordering =</span><br><span class="line">      <span class="keyword">new</span> ceres::ParameterBlockOrdering;</span><br><span class="line">  <span class="comment">// The points come before the cameras.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i) &#123;</span><br><span class="line">    ordering-&gt;AddElementToGroup(points + point_block_size * i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i) &#123;</span><br><span class="line">    <span class="comment">// When using axis-angle, there is a single parameter block for</span></span><br><span class="line">    <span class="comment">// the entire camera.</span></span><br><span class="line">    ordering-&gt;AddElementToGroup(cameras + camera_block_size * i, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  options-&gt;linear_solver_ordering.reset(ordering);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetMinimizerOptions</span><span class="params">(Solver::Options* options)</span> </span>&#123;</span><br><span class="line">  options-&gt;max_num_iterations = FLAGS_num_iterations;</span><br><span class="line">  options-&gt;minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">  options-&gt;num_threads = FLAGS_num_threads;</span><br><span class="line">  options-&gt;eta = FLAGS_eta;</span><br><span class="line">  options-&gt;max_solver_time_in_seconds = FLAGS_max_solver_time;</span><br><span class="line">  options-&gt;use_nonmonotonic_steps = FLAGS_nonmonotonic_steps;</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_line_search) &#123;</span><br><span class="line">    options-&gt;minimizer_type = ceres::LINE_SEARCH;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(StringToTrustRegionStrategyType(FLAGS_trust_region_strategy,</span><br><span class="line">                                        &amp;options-&gt;trust_region_strategy_type));</span><br><span class="line">  CHECK(StringToDoglegType(FLAGS_dogleg, &amp;options-&gt;dogleg_type));</span><br><span class="line">  options-&gt;use_inner_iterations = FLAGS_inner_iterations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSolverOptionsFromFlags</span><span class="params">(BALProblem* bal_problem,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Solver::Options* options)</span> </span>&#123;</span><br><span class="line">  SetMinimizerOptions(options);</span><br><span class="line">  SetLinearSolver(options);</span><br><span class="line">  SetOrdering(bal_problem, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildProblem</span><span class="params">(BALProblem* bal_problem, Problem* problem)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> point_block_size = bal_problem-&gt;point_block_size();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> camera_block_size = bal_problem-&gt;camera_block_size();</span><br><span class="line">  <span class="keyword">double</span>* points = bal_problem-&gt;mutable_points();</span><br><span class="line">  <span class="keyword">double</span>* cameras = bal_problem-&gt;mutable_cameras();</span><br><span class="line">  <span class="comment">// Observations is 2*num_observations long array observations =</span></span><br><span class="line">  <span class="comment">// [u_1, u_2, ... , u_n], where each u_i is two dimensional, the x</span></span><br><span class="line">  <span class="comment">// and y positions of the observation.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span>* observations = bal_problem-&gt;observations();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem-&gt;num_observations(); ++i) &#123;</span><br><span class="line">    CostFunction* cost_function;</span><br><span class="line">    <span class="comment">// Each Residual block takes a point and a camera as input and</span></span><br><span class="line">    <span class="comment">// outputs a 2 dimensional residual.</span></span><br><span class="line">    cost_function =</span><br><span class="line">        (FLAGS_use_quaternions)</span><br><span class="line">        ? SnavelyReprojectionErrorWithQuaternions::Create(</span><br><span class="line">            observations[<span class="number">2</span> * i + <span class="number">0</span>],</span><br><span class="line">            observations[<span class="number">2</span> * i + <span class="number">1</span>])</span><br><span class="line">        : SnavelyReprojectionError::Create(</span><br><span class="line">            observations[<span class="number">2</span> * i + <span class="number">0</span>],</span><br><span class="line">            observations[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// If enabled use Huber's loss function.</span></span><br><span class="line">    LossFunction* loss_function = FLAGS_robustify ? <span class="keyword">new</span> HuberLoss(<span class="number">1.0</span>) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Each observation correponds to a pair of a camera and a point</span></span><br><span class="line">    <span class="comment">// which are identified by camera_index()[i] and point_index()[i]</span></span><br><span class="line">    <span class="comment">// respectively.</span></span><br><span class="line">    <span class="keyword">double</span>* camera =</span><br><span class="line">        cameras + camera_block_size * bal_problem-&gt;camera_index()[i];</span><br><span class="line">    <span class="keyword">double</span>* point = points + point_block_size * bal_problem-&gt;point_index()[i];</span><br><span class="line">    problem-&gt;AddResidualBlock(cost_function, loss_function, camera, point);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_use_quaternions &amp;&amp; FLAGS_use_local_parameterization) &#123;</span><br><span class="line">    LocalParameterization* camera_parameterization =</span><br><span class="line">        <span class="keyword">new</span> ProductParameterization(</span><br><span class="line">            <span class="keyword">new</span> QuaternionParameterization(),</span><br><span class="line">            <span class="keyword">new</span> IdentityParameterization(<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem-&gt;num_cameras(); ++i) &#123;</span><br><span class="line">      problem-&gt;SetParameterization(cameras + camera_block_size * i,</span><br><span class="line">                                   camera_parameterization);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SolveProblem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">  <span class="function">BALProblem <span class="title">bal_problem</span><span class="params">(filename, FLAGS_use_quaternions)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_initial_ply.empty()) &#123;</span><br><span class="line">    bal_problem.WriteToPLYFile(FLAGS_initial_ply);</span><br><span class="line">  &#125;</span><br><span class="line">  Problem problem;</span><br><span class="line">  srand(FLAGS_random_seed);</span><br><span class="line">  bal_problem.Normalize();</span><br><span class="line">  bal_problem.Perturb(FLAGS_rotation_sigma,</span><br><span class="line">                      FLAGS_translation_sigma,</span><br><span class="line">                      FLAGS_point_sigma);</span><br><span class="line">  BuildProblem(&amp;bal_problem, &amp;problem);</span><br><span class="line">  Solver::Options options;</span><br><span class="line">  SetSolverOptionsFromFlags(&amp;bal_problem, &amp;options);</span><br><span class="line">  options.gradient_tolerance = <span class="number">1e-16</span>;</span><br><span class="line">  options.function_tolerance = <span class="number">1e-16</span>;</span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_final_ply.empty()) &#123;</span><br><span class="line">    bal_problem.WriteToPLYFile(FLAGS_final_ply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line">&#125;  <span class="comment">// namespace examples</span></span><br><span class="line">&#125;  <span class="comment">// namespace ceres</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  CERES_GFLAGS_NAMESPACE::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_input.empty()) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Usage: bundle_adjuster --input=bal_problem"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(FLAGS_use_quaternions || !FLAGS_use_local_parameterization)</span><br><span class="line">      &lt;&lt; <span class="string">"--use_local_parameterization can only be used with "</span></span><br><span class="line">      &lt;&lt; <span class="string">"--use_quaternions."</span>;</span><br><span class="line">  ceres::examples::SolveProblem(FLAGS_input.c_str());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/ceres/">ceres</a></div><div class="post-nav"><a class="pre" href="/2019/09/28/BA理论解读/">BA理论解读</a><a class="next" href="/2019/08/18/ceres库基本介绍/">ceres库基本</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ceres/" style="font-size: 15px;">ceres</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/28/BA理论解读/">BA理论解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/18/ceres库使用说明/">ceres库使用说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/18/ceres库基本介绍/">ceres库基本</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">SUQIGUANG's BLOG.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>